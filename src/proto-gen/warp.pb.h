// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: warp.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_warp_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_warp_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3018000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3018000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_warp_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_warp_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[11]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_warp_2eproto;
class FileChunk;
struct FileChunkDefaultTypeInternal;
extern FileChunkDefaultTypeInternal _FileChunk_default_instance_;
class HaveDuplex;
struct HaveDuplexDefaultTypeInternal;
extern HaveDuplexDefaultTypeInternal _HaveDuplex_default_instance_;
class LookupName;
struct LookupNameDefaultTypeInternal;
extern LookupNameDefaultTypeInternal _LookupName_default_instance_;
class OpInfo;
struct OpInfoDefaultTypeInternal;
extern OpInfoDefaultTypeInternal _OpInfo_default_instance_;
class RegRequest;
struct RegRequestDefaultTypeInternal;
extern RegRequestDefaultTypeInternal _RegRequest_default_instance_;
class RegResponse;
struct RegResponseDefaultTypeInternal;
extern RegResponseDefaultTypeInternal _RegResponse_default_instance_;
class RemoteMachineAvatar;
struct RemoteMachineAvatarDefaultTypeInternal;
extern RemoteMachineAvatarDefaultTypeInternal _RemoteMachineAvatar_default_instance_;
class RemoteMachineInfo;
struct RemoteMachineInfoDefaultTypeInternal;
extern RemoteMachineInfoDefaultTypeInternal _RemoteMachineInfo_default_instance_;
class StopInfo;
struct StopInfoDefaultTypeInternal;
extern StopInfoDefaultTypeInternal _StopInfo_default_instance_;
class TransferOpRequest;
struct TransferOpRequestDefaultTypeInternal;
extern TransferOpRequestDefaultTypeInternal _TransferOpRequest_default_instance_;
class VoidType;
struct VoidTypeDefaultTypeInternal;
extern VoidTypeDefaultTypeInternal _VoidType_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::FileChunk* Arena::CreateMaybeMessage<::FileChunk>(Arena*);
template<> ::HaveDuplex* Arena::CreateMaybeMessage<::HaveDuplex>(Arena*);
template<> ::LookupName* Arena::CreateMaybeMessage<::LookupName>(Arena*);
template<> ::OpInfo* Arena::CreateMaybeMessage<::OpInfo>(Arena*);
template<> ::RegRequest* Arena::CreateMaybeMessage<::RegRequest>(Arena*);
template<> ::RegResponse* Arena::CreateMaybeMessage<::RegResponse>(Arena*);
template<> ::RemoteMachineAvatar* Arena::CreateMaybeMessage<::RemoteMachineAvatar>(Arena*);
template<> ::RemoteMachineInfo* Arena::CreateMaybeMessage<::RemoteMachineInfo>(Arena*);
template<> ::StopInfo* Arena::CreateMaybeMessage<::StopInfo>(Arena*);
template<> ::TransferOpRequest* Arena::CreateMaybeMessage<::TransferOpRequest>(Arena*);
template<> ::VoidType* Arena::CreateMaybeMessage<::VoidType>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class RemoteMachineInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoteMachineInfo) */ {
 public:
  inline RemoteMachineInfo() : RemoteMachineInfo(nullptr) {}
  ~RemoteMachineInfo() override;
  explicit constexpr RemoteMachineInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteMachineInfo(const RemoteMachineInfo& from);
  RemoteMachineInfo(RemoteMachineInfo&& from) noexcept
    : RemoteMachineInfo() {
    *this = ::std::move(from);
  }

  inline RemoteMachineInfo& operator=(const RemoteMachineInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteMachineInfo& operator=(RemoteMachineInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteMachineInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteMachineInfo* internal_default_instance() {
    return reinterpret_cast<const RemoteMachineInfo*>(
               &_RemoteMachineInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(RemoteMachineInfo& a, RemoteMachineInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteMachineInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteMachineInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteMachineInfo* New() const final {
    return new RemoteMachineInfo();
  }

  RemoteMachineInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteMachineInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteMachineInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoteMachineInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteMachineInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteMachineInfo";
  }
  protected:
  explicit RemoteMachineInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDisplayNameFieldNumber = 1,
    kUserNameFieldNumber = 2,
  };
  // string display_name = 1;
  void clear_display_name();
  const std::string& display_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_display_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_display_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_display_name();
  void set_allocated_display_name(std::string* display_name);
  private:
  const std::string& _internal_display_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_display_name(const std::string& value);
  std::string* _internal_mutable_display_name();
  public:

  // string user_name = 2;
  void clear_user_name();
  const std::string& user_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_user_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_user_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_user_name();
  void set_allocated_user_name(std::string* user_name);
  private:
  const std::string& _internal_user_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_user_name(const std::string& value);
  std::string* _internal_mutable_user_name();
  public:

  // @@protoc_insertion_point(class_scope:RemoteMachineInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr display_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr user_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class RemoteMachineAvatar final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RemoteMachineAvatar) */ {
 public:
  inline RemoteMachineAvatar() : RemoteMachineAvatar(nullptr) {}
  ~RemoteMachineAvatar() override;
  explicit constexpr RemoteMachineAvatar(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RemoteMachineAvatar(const RemoteMachineAvatar& from);
  RemoteMachineAvatar(RemoteMachineAvatar&& from) noexcept
    : RemoteMachineAvatar() {
    *this = ::std::move(from);
  }

  inline RemoteMachineAvatar& operator=(const RemoteMachineAvatar& from) {
    CopyFrom(from);
    return *this;
  }
  inline RemoteMachineAvatar& operator=(RemoteMachineAvatar&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RemoteMachineAvatar& default_instance() {
    return *internal_default_instance();
  }
  static inline const RemoteMachineAvatar* internal_default_instance() {
    return reinterpret_cast<const RemoteMachineAvatar*>(
               &_RemoteMachineAvatar_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(RemoteMachineAvatar& a, RemoteMachineAvatar& b) {
    a.Swap(&b);
  }
  inline void Swap(RemoteMachineAvatar* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RemoteMachineAvatar* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RemoteMachineAvatar* New() const final {
    return new RemoteMachineAvatar();
  }

  RemoteMachineAvatar* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RemoteMachineAvatar>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RemoteMachineAvatar& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RemoteMachineAvatar& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RemoteMachineAvatar* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RemoteMachineAvatar";
  }
  protected:
  explicit RemoteMachineAvatar(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAvatarChunkFieldNumber = 1,
  };
  // bytes avatar_chunk = 1;
  void clear_avatar_chunk();
  const std::string& avatar_chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_avatar_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_avatar_chunk();
  PROTOBUF_MUST_USE_RESULT std::string* release_avatar_chunk();
  void set_allocated_avatar_chunk(std::string* avatar_chunk);
  private:
  const std::string& _internal_avatar_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_avatar_chunk(const std::string& value);
  std::string* _internal_mutable_avatar_chunk();
  public:

  // @@protoc_insertion_point(class_scope:RemoteMachineAvatar)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr avatar_chunk_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class LookupName final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:LookupName) */ {
 public:
  inline LookupName() : LookupName(nullptr) {}
  ~LookupName() override;
  explicit constexpr LookupName(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  LookupName(const LookupName& from);
  LookupName(LookupName&& from) noexcept
    : LookupName() {
    *this = ::std::move(from);
  }

  inline LookupName& operator=(const LookupName& from) {
    CopyFrom(from);
    return *this;
  }
  inline LookupName& operator=(LookupName&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const LookupName& default_instance() {
    return *internal_default_instance();
  }
  static inline const LookupName* internal_default_instance() {
    return reinterpret_cast<const LookupName*>(
               &_LookupName_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(LookupName& a, LookupName& b) {
    a.Swap(&b);
  }
  inline void Swap(LookupName* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(LookupName* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline LookupName* New() const final {
    return new LookupName();
  }

  LookupName* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<LookupName>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const LookupName& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const LookupName& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LookupName* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "LookupName";
  }
  protected:
  explicit LookupName(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kReadableNameFieldNumber = 2,
  };
  // string id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // string readable_name = 2;
  void clear_readable_name();
  const std::string& readable_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_readable_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_readable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_readable_name();
  void set_allocated_readable_name(std::string* readable_name);
  private:
  const std::string& _internal_readable_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_readable_name(const std::string& value);
  std::string* _internal_mutable_readable_name();
  public:

  // @@protoc_insertion_point(class_scope:LookupName)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr readable_name_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class HaveDuplex final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:HaveDuplex) */ {
 public:
  inline HaveDuplex() : HaveDuplex(nullptr) {}
  ~HaveDuplex() override;
  explicit constexpr HaveDuplex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  HaveDuplex(const HaveDuplex& from);
  HaveDuplex(HaveDuplex&& from) noexcept
    : HaveDuplex() {
    *this = ::std::move(from);
  }

  inline HaveDuplex& operator=(const HaveDuplex& from) {
    CopyFrom(from);
    return *this;
  }
  inline HaveDuplex& operator=(HaveDuplex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const HaveDuplex& default_instance() {
    return *internal_default_instance();
  }
  static inline const HaveDuplex* internal_default_instance() {
    return reinterpret_cast<const HaveDuplex*>(
               &_HaveDuplex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(HaveDuplex& a, HaveDuplex& b) {
    a.Swap(&b);
  }
  inline void Swap(HaveDuplex* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(HaveDuplex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline HaveDuplex* New() const final {
    return new HaveDuplex();
  }

  HaveDuplex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<HaveDuplex>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const HaveDuplex& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const HaveDuplex& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(HaveDuplex* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "HaveDuplex";
  }
  protected:
  explicit HaveDuplex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kResponseFieldNumber = 2,
  };
  // bool response = 2;
  void clear_response();
  bool response() const;
  void set_response(bool value);
  private:
  bool _internal_response() const;
  void _internal_set_response(bool value);
  public:

  // @@protoc_insertion_point(class_scope:HaveDuplex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool response_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class VoidType final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VoidType) */ {
 public:
  inline VoidType() : VoidType(nullptr) {}
  ~VoidType() override;
  explicit constexpr VoidType(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VoidType(const VoidType& from);
  VoidType(VoidType&& from) noexcept
    : VoidType() {
    *this = ::std::move(from);
  }

  inline VoidType& operator=(const VoidType& from) {
    CopyFrom(from);
    return *this;
  }
  inline VoidType& operator=(VoidType&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VoidType& default_instance() {
    return *internal_default_instance();
  }
  static inline const VoidType* internal_default_instance() {
    return reinterpret_cast<const VoidType*>(
               &_VoidType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(VoidType& a, VoidType& b) {
    a.Swap(&b);
  }
  inline void Swap(VoidType* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VoidType* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline VoidType* New() const final {
    return new VoidType();
  }

  VoidType* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<VoidType>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VoidType& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VoidType& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VoidType* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VoidType";
  }
  protected:
  explicit VoidType(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDummyFieldNumber = 1,
  };
  // int32 dummy = 1;
  void clear_dummy();
  ::PROTOBUF_NAMESPACE_ID::int32 dummy() const;
  void set_dummy(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_dummy() const;
  void _internal_set_dummy(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:VoidType)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int32 dummy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class OpInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:OpInfo) */ {
 public:
  inline OpInfo() : OpInfo(nullptr) {}
  ~OpInfo() override;
  explicit constexpr OpInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  OpInfo(const OpInfo& from);
  OpInfo(OpInfo&& from) noexcept
    : OpInfo() {
    *this = ::std::move(from);
  }

  inline OpInfo& operator=(const OpInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline OpInfo& operator=(OpInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const OpInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const OpInfo* internal_default_instance() {
    return reinterpret_cast<const OpInfo*>(
               &_OpInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(OpInfo& a, OpInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(OpInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(OpInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline OpInfo* New() const final {
    return new OpInfo();
  }

  OpInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<OpInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const OpInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const OpInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OpInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "OpInfo";
  }
  protected:
  explicit OpInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdentFieldNumber = 1,
    kReadableNameFieldNumber = 3,
    kTimestampFieldNumber = 2,
    kUseCompressionFieldNumber = 4,
  };
  // string ident = 1;
  void clear_ident();
  const std::string& ident() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ident(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ident();
  PROTOBUF_MUST_USE_RESULT std::string* release_ident();
  void set_allocated_ident(std::string* ident);
  private:
  const std::string& _internal_ident() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ident(const std::string& value);
  std::string* _internal_mutable_ident();
  public:

  // string readable_name = 3;
  void clear_readable_name();
  const std::string& readable_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_readable_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_readable_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_readable_name();
  void set_allocated_readable_name(std::string* readable_name);
  private:
  const std::string& _internal_readable_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_readable_name(const std::string& value);
  std::string* _internal_mutable_readable_name();
  public:

  // uint64 timestamp = 2;
  void clear_timestamp();
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp() const;
  void set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_timestamp() const;
  void _internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // bool use_compression = 4;
  void clear_use_compression();
  bool use_compression() const;
  void set_use_compression(bool value);
  private:
  bool _internal_use_compression() const;
  void _internal_set_use_compression(bool value);
  public:

  // @@protoc_insertion_point(class_scope:OpInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ident_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr readable_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 timestamp_;
  bool use_compression_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class StopInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:StopInfo) */ {
 public:
  inline StopInfo() : StopInfo(nullptr) {}
  ~StopInfo() override;
  explicit constexpr StopInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StopInfo(const StopInfo& from);
  StopInfo(StopInfo&& from) noexcept
    : StopInfo() {
    *this = ::std::move(from);
  }

  inline StopInfo& operator=(const StopInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline StopInfo& operator=(StopInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const StopInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const StopInfo* internal_default_instance() {
    return reinterpret_cast<const StopInfo*>(
               &_StopInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(StopInfo& a, StopInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(StopInfo* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StopInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline StopInfo* New() const final {
    return new StopInfo();
  }

  StopInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<StopInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const StopInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const StopInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StopInfo* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "StopInfo";
  }
  protected:
  explicit StopInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInfoFieldNumber = 1,
    kErrorFieldNumber = 2,
  };
  // .OpInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::OpInfo& info() const;
  PROTOBUF_MUST_USE_RESULT ::OpInfo* release_info();
  ::OpInfo* mutable_info();
  void set_allocated_info(::OpInfo* info);
  private:
  const ::OpInfo& _internal_info() const;
  ::OpInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::OpInfo* info);
  ::OpInfo* unsafe_arena_release_info();

  // bool error = 2;
  void clear_error();
  bool error() const;
  void set_error(bool value);
  private:
  bool _internal_error() const;
  void _internal_set_error(bool value);
  public:

  // @@protoc_insertion_point(class_scope:StopInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::OpInfo* info_;
  bool error_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class TransferOpRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:TransferOpRequest) */ {
 public:
  inline TransferOpRequest() : TransferOpRequest(nullptr) {}
  ~TransferOpRequest() override;
  explicit constexpr TransferOpRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransferOpRequest(const TransferOpRequest& from);
  TransferOpRequest(TransferOpRequest&& from) noexcept
    : TransferOpRequest() {
    *this = ::std::move(from);
  }

  inline TransferOpRequest& operator=(const TransferOpRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransferOpRequest& operator=(TransferOpRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransferOpRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransferOpRequest* internal_default_instance() {
    return reinterpret_cast<const TransferOpRequest*>(
               &_TransferOpRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(TransferOpRequest& a, TransferOpRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(TransferOpRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransferOpRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransferOpRequest* New() const final {
    return new TransferOpRequest();
  }

  TransferOpRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransferOpRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransferOpRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransferOpRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransferOpRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "TransferOpRequest";
  }
  protected:
  explicit TransferOpRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTopDirBasenamesFieldNumber = 9,
    kSenderNameFieldNumber = 2,
    kReceiverNameFieldNumber = 3,
    kReceiverFieldNumber = 4,
    kNameIfSingleFieldNumber = 7,
    kMimeIfSingleFieldNumber = 8,
    kInfoFieldNumber = 1,
    kSizeFieldNumber = 5,
    kCountFieldNumber = 6,
  };
  // repeated string top_dir_basenames = 9;
  int top_dir_basenames_size() const;
  private:
  int _internal_top_dir_basenames_size() const;
  public:
  void clear_top_dir_basenames();
  const std::string& top_dir_basenames(int index) const;
  std::string* mutable_top_dir_basenames(int index);
  void set_top_dir_basenames(int index, const std::string& value);
  void set_top_dir_basenames(int index, std::string&& value);
  void set_top_dir_basenames(int index, const char* value);
  void set_top_dir_basenames(int index, const char* value, size_t size);
  std::string* add_top_dir_basenames();
  void add_top_dir_basenames(const std::string& value);
  void add_top_dir_basenames(std::string&& value);
  void add_top_dir_basenames(const char* value);
  void add_top_dir_basenames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& top_dir_basenames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_top_dir_basenames();
  private:
  const std::string& _internal_top_dir_basenames(int index) const;
  std::string* _internal_add_top_dir_basenames();
  public:

  // string sender_name = 2;
  void clear_sender_name();
  const std::string& sender_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sender_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sender_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_sender_name();
  void set_allocated_sender_name(std::string* sender_name);
  private:
  const std::string& _internal_sender_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sender_name(const std::string& value);
  std::string* _internal_mutable_sender_name();
  public:

  // string receiver_name = 3;
  void clear_receiver_name();
  const std::string& receiver_name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver_name();
  PROTOBUF_MUST_USE_RESULT std::string* release_receiver_name();
  void set_allocated_receiver_name(std::string* receiver_name);
  private:
  const std::string& _internal_receiver_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver_name(const std::string& value);
  std::string* _internal_mutable_receiver_name();
  public:

  // string receiver = 4;
  void clear_receiver();
  const std::string& receiver() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_receiver(ArgT0&& arg0, ArgT... args);
  std::string* mutable_receiver();
  PROTOBUF_MUST_USE_RESULT std::string* release_receiver();
  void set_allocated_receiver(std::string* receiver);
  private:
  const std::string& _internal_receiver() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_receiver(const std::string& value);
  std::string* _internal_mutable_receiver();
  public:

  // string name_if_single = 7;
  void clear_name_if_single();
  const std::string& name_if_single() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name_if_single(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name_if_single();
  PROTOBUF_MUST_USE_RESULT std::string* release_name_if_single();
  void set_allocated_name_if_single(std::string* name_if_single);
  private:
  const std::string& _internal_name_if_single() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name_if_single(const std::string& value);
  std::string* _internal_mutable_name_if_single();
  public:

  // string mime_if_single = 8;
  void clear_mime_if_single();
  const std::string& mime_if_single() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_mime_if_single(ArgT0&& arg0, ArgT... args);
  std::string* mutable_mime_if_single();
  PROTOBUF_MUST_USE_RESULT std::string* release_mime_if_single();
  void set_allocated_mime_if_single(std::string* mime_if_single);
  private:
  const std::string& _internal_mime_if_single() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_mime_if_single(const std::string& value);
  std::string* _internal_mutable_mime_if_single();
  public:

  // .OpInfo info = 1;
  bool has_info() const;
  private:
  bool _internal_has_info() const;
  public:
  void clear_info();
  const ::OpInfo& info() const;
  PROTOBUF_MUST_USE_RESULT ::OpInfo* release_info();
  ::OpInfo* mutable_info();
  void set_allocated_info(::OpInfo* info);
  private:
  const ::OpInfo& _internal_info() const;
  ::OpInfo* _internal_mutable_info();
  public:
  void unsafe_arena_set_allocated_info(
      ::OpInfo* info);
  ::OpInfo* unsafe_arena_release_info();

  // uint64 size = 5;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_size() const;
  void _internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 count = 6;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_count() const;
  void _internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:TransferOpRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> top_dir_basenames_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sender_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr receiver_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_if_single_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr mime_if_single_;
  ::OpInfo* info_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 count_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class FileChunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:FileChunk) */ {
 public:
  inline FileChunk() : FileChunk(nullptr) {}
  ~FileChunk() override;
  explicit constexpr FileChunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  FileChunk(const FileChunk& from);
  FileChunk(FileChunk&& from) noexcept
    : FileChunk() {
    *this = ::std::move(from);
  }

  inline FileChunk& operator=(const FileChunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline FileChunk& operator=(FileChunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const FileChunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const FileChunk* internal_default_instance() {
    return reinterpret_cast<const FileChunk*>(
               &_FileChunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(FileChunk& a, FileChunk& b) {
    a.Swap(&b);
  }
  inline void Swap(FileChunk* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(FileChunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline FileChunk* New() const final {
    return new FileChunk();
  }

  FileChunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<FileChunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const FileChunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const FileChunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FileChunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "FileChunk";
  }
  protected:
  explicit FileChunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRelativePathFieldNumber = 1,
    kSymlinkTargetFieldNumber = 3,
    kChunkFieldNumber = 4,
    kFileTypeFieldNumber = 2,
    kFileModeFieldNumber = 5,
  };
  // string relative_path = 1;
  void clear_relative_path();
  const std::string& relative_path() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_relative_path(ArgT0&& arg0, ArgT... args);
  std::string* mutable_relative_path();
  PROTOBUF_MUST_USE_RESULT std::string* release_relative_path();
  void set_allocated_relative_path(std::string* relative_path);
  private:
  const std::string& _internal_relative_path() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_relative_path(const std::string& value);
  std::string* _internal_mutable_relative_path();
  public:

  // string symlink_target = 3;
  void clear_symlink_target();
  const std::string& symlink_target() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_symlink_target(ArgT0&& arg0, ArgT... args);
  std::string* mutable_symlink_target();
  PROTOBUF_MUST_USE_RESULT std::string* release_symlink_target();
  void set_allocated_symlink_target(std::string* symlink_target);
  private:
  const std::string& _internal_symlink_target() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_symlink_target(const std::string& value);
  std::string* _internal_mutable_symlink_target();
  public:

  // bytes chunk = 4;
  void clear_chunk();
  const std::string& chunk() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chunk(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chunk();
  PROTOBUF_MUST_USE_RESULT std::string* release_chunk();
  void set_allocated_chunk(std::string* chunk);
  private:
  const std::string& _internal_chunk() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chunk(const std::string& value);
  std::string* _internal_mutable_chunk();
  public:

  // int32 file_type = 2;
  void clear_file_type();
  ::PROTOBUF_NAMESPACE_ID::int32 file_type() const;
  void set_file_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_file_type() const;
  void _internal_set_file_type(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // uint32 file_mode = 5;
  void clear_file_mode();
  ::PROTOBUF_NAMESPACE_ID::uint32 file_mode() const;
  void set_file_mode(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_file_mode() const;
  void _internal_set_file_mode(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:FileChunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr relative_path_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr symlink_target_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chunk_;
  ::PROTOBUF_NAMESPACE_ID::int32 file_type_;
  ::PROTOBUF_NAMESPACE_ID::uint32 file_mode_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class RegRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegRequest) */ {
 public:
  inline RegRequest() : RegRequest(nullptr) {}
  ~RegRequest() override;
  explicit constexpr RegRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegRequest(const RegRequest& from);
  RegRequest(RegRequest&& from) noexcept
    : RegRequest() {
    *this = ::std::move(from);
  }

  inline RegRequest& operator=(const RegRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegRequest& operator=(RegRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegRequest* internal_default_instance() {
    return reinterpret_cast<const RegRequest*>(
               &_RegRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(RegRequest& a, RegRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(RegRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegRequest* New() const final {
    return new RegRequest();
  }

  RegRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegRequest";
  }
  protected:
  explicit RegRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIpFieldNumber = 1,
    kHostnameFieldNumber = 2,
  };
  // string ip = 1;
  void clear_ip();
  const std::string& ip() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_ip(ArgT0&& arg0, ArgT... args);
  std::string* mutable_ip();
  PROTOBUF_MUST_USE_RESULT std::string* release_ip();
  void set_allocated_ip(std::string* ip);
  private:
  const std::string& _internal_ip() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_ip(const std::string& value);
  std::string* _internal_mutable_ip();
  public:

  // string hostname = 2;
  void clear_hostname();
  const std::string& hostname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_hostname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_hostname();
  PROTOBUF_MUST_USE_RESULT std::string* release_hostname();
  void set_allocated_hostname(std::string* hostname);
  private:
  const std::string& _internal_hostname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_hostname(const std::string& value);
  std::string* _internal_mutable_hostname();
  public:

  // @@protoc_insertion_point(class_scope:RegRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr ip_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr hostname_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// -------------------------------------------------------------------

class RegResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:RegResponse) */ {
 public:
  inline RegResponse() : RegResponse(nullptr) {}
  ~RegResponse() override;
  explicit constexpr RegResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  RegResponse(const RegResponse& from);
  RegResponse(RegResponse&& from) noexcept
    : RegResponse() {
    *this = ::std::move(from);
  }

  inline RegResponse& operator=(const RegResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline RegResponse& operator=(RegResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const RegResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const RegResponse* internal_default_instance() {
    return reinterpret_cast<const RegResponse*>(
               &_RegResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(RegResponse& a, RegResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(RegResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(RegResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline RegResponse* New() const final {
    return new RegResponse();
  }

  RegResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<RegResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const RegResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const RegResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RegResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "RegResponse";
  }
  protected:
  explicit RegResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLockedCertFieldNumber = 1,
  };
  // string locked_cert = 1;
  void clear_locked_cert();
  const std::string& locked_cert() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_locked_cert(ArgT0&& arg0, ArgT... args);
  std::string* mutable_locked_cert();
  PROTOBUF_MUST_USE_RESULT std::string* release_locked_cert();
  void set_allocated_locked_cert(std::string* locked_cert);
  private:
  const std::string& _internal_locked_cert() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_locked_cert(const std::string& value);
  std::string* _internal_mutable_locked_cert();
  public:

  // @@protoc_insertion_point(class_scope:RegResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr locked_cert_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_warp_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// RemoteMachineInfo

// string display_name = 1;
inline void RemoteMachineInfo::clear_display_name() {
  display_name_.ClearToEmpty();
}
inline const std::string& RemoteMachineInfo::display_name() const {
  // @@protoc_insertion_point(field_get:RemoteMachineInfo.display_name)
  return _internal_display_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteMachineInfo::set_display_name(ArgT0&& arg0, ArgT... args) {
 
 display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoteMachineInfo.display_name)
}
inline std::string* RemoteMachineInfo::mutable_display_name() {
  std::string* _s = _internal_mutable_display_name();
  // @@protoc_insertion_point(field_mutable:RemoteMachineInfo.display_name)
  return _s;
}
inline const std::string& RemoteMachineInfo::_internal_display_name() const {
  return display_name_.Get();
}
inline void RemoteMachineInfo::_internal_set_display_name(const std::string& value) {
  
  display_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoteMachineInfo::_internal_mutable_display_name() {
  
  return display_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoteMachineInfo::release_display_name() {
  // @@protoc_insertion_point(field_release:RemoteMachineInfo.display_name)
  return display_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoteMachineInfo::set_allocated_display_name(std::string* display_name) {
  if (display_name != nullptr) {
    
  } else {
    
  }
  display_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), display_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RemoteMachineInfo.display_name)
}

// string user_name = 2;
inline void RemoteMachineInfo::clear_user_name() {
  user_name_.ClearToEmpty();
}
inline const std::string& RemoteMachineInfo::user_name() const {
  // @@protoc_insertion_point(field_get:RemoteMachineInfo.user_name)
  return _internal_user_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteMachineInfo::set_user_name(ArgT0&& arg0, ArgT... args) {
 
 user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoteMachineInfo.user_name)
}
inline std::string* RemoteMachineInfo::mutable_user_name() {
  std::string* _s = _internal_mutable_user_name();
  // @@protoc_insertion_point(field_mutable:RemoteMachineInfo.user_name)
  return _s;
}
inline const std::string& RemoteMachineInfo::_internal_user_name() const {
  return user_name_.Get();
}
inline void RemoteMachineInfo::_internal_set_user_name(const std::string& value) {
  
  user_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoteMachineInfo::_internal_mutable_user_name() {
  
  return user_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoteMachineInfo::release_user_name() {
  // @@protoc_insertion_point(field_release:RemoteMachineInfo.user_name)
  return user_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoteMachineInfo::set_allocated_user_name(std::string* user_name) {
  if (user_name != nullptr) {
    
  } else {
    
  }
  user_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), user_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RemoteMachineInfo.user_name)
}

// -------------------------------------------------------------------

// RemoteMachineAvatar

// bytes avatar_chunk = 1;
inline void RemoteMachineAvatar::clear_avatar_chunk() {
  avatar_chunk_.ClearToEmpty();
}
inline const std::string& RemoteMachineAvatar::avatar_chunk() const {
  // @@protoc_insertion_point(field_get:RemoteMachineAvatar.avatar_chunk)
  return _internal_avatar_chunk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RemoteMachineAvatar::set_avatar_chunk(ArgT0&& arg0, ArgT... args) {
 
 avatar_chunk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RemoteMachineAvatar.avatar_chunk)
}
inline std::string* RemoteMachineAvatar::mutable_avatar_chunk() {
  std::string* _s = _internal_mutable_avatar_chunk();
  // @@protoc_insertion_point(field_mutable:RemoteMachineAvatar.avatar_chunk)
  return _s;
}
inline const std::string& RemoteMachineAvatar::_internal_avatar_chunk() const {
  return avatar_chunk_.Get();
}
inline void RemoteMachineAvatar::_internal_set_avatar_chunk(const std::string& value) {
  
  avatar_chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RemoteMachineAvatar::_internal_mutable_avatar_chunk() {
  
  return avatar_chunk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RemoteMachineAvatar::release_avatar_chunk() {
  // @@protoc_insertion_point(field_release:RemoteMachineAvatar.avatar_chunk)
  return avatar_chunk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RemoteMachineAvatar::set_allocated_avatar_chunk(std::string* avatar_chunk) {
  if (avatar_chunk != nullptr) {
    
  } else {
    
  }
  avatar_chunk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), avatar_chunk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RemoteMachineAvatar.avatar_chunk)
}

// -------------------------------------------------------------------

// LookupName

// string id = 1;
inline void LookupName::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& LookupName::id() const {
  // @@protoc_insertion_point(field_get:LookupName.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupName::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LookupName.id)
}
inline std::string* LookupName::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:LookupName.id)
  return _s;
}
inline const std::string& LookupName::_internal_id() const {
  return id_.Get();
}
inline void LookupName::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LookupName::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LookupName::release_id() {
  // @@protoc_insertion_point(field_release:LookupName.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LookupName::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:LookupName.id)
}

// string readable_name = 2;
inline void LookupName::clear_readable_name() {
  readable_name_.ClearToEmpty();
}
inline const std::string& LookupName::readable_name() const {
  // @@protoc_insertion_point(field_get:LookupName.readable_name)
  return _internal_readable_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void LookupName::set_readable_name(ArgT0&& arg0, ArgT... args) {
 
 readable_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:LookupName.readable_name)
}
inline std::string* LookupName::mutable_readable_name() {
  std::string* _s = _internal_mutable_readable_name();
  // @@protoc_insertion_point(field_mutable:LookupName.readable_name)
  return _s;
}
inline const std::string& LookupName::_internal_readable_name() const {
  return readable_name_.Get();
}
inline void LookupName::_internal_set_readable_name(const std::string& value) {
  
  readable_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* LookupName::_internal_mutable_readable_name() {
  
  return readable_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* LookupName::release_readable_name() {
  // @@protoc_insertion_point(field_release:LookupName.readable_name)
  return readable_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void LookupName::set_allocated_readable_name(std::string* readable_name) {
  if (readable_name != nullptr) {
    
  } else {
    
  }
  readable_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), readable_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:LookupName.readable_name)
}

// -------------------------------------------------------------------

// HaveDuplex

// bool response = 2;
inline void HaveDuplex::clear_response() {
  response_ = false;
}
inline bool HaveDuplex::_internal_response() const {
  return response_;
}
inline bool HaveDuplex::response() const {
  // @@protoc_insertion_point(field_get:HaveDuplex.response)
  return _internal_response();
}
inline void HaveDuplex::_internal_set_response(bool value) {
  
  response_ = value;
}
inline void HaveDuplex::set_response(bool value) {
  _internal_set_response(value);
  // @@protoc_insertion_point(field_set:HaveDuplex.response)
}

// -------------------------------------------------------------------

// VoidType

// int32 dummy = 1;
inline void VoidType::clear_dummy() {
  dummy_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VoidType::_internal_dummy() const {
  return dummy_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 VoidType::dummy() const {
  // @@protoc_insertion_point(field_get:VoidType.dummy)
  return _internal_dummy();
}
inline void VoidType::_internal_set_dummy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  dummy_ = value;
}
inline void VoidType::set_dummy(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_dummy(value);
  // @@protoc_insertion_point(field_set:VoidType.dummy)
}

// -------------------------------------------------------------------

// OpInfo

// string ident = 1;
inline void OpInfo::clear_ident() {
  ident_.ClearToEmpty();
}
inline const std::string& OpInfo::ident() const {
  // @@protoc_insertion_point(field_get:OpInfo.ident)
  return _internal_ident();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpInfo::set_ident(ArgT0&& arg0, ArgT... args) {
 
 ident_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpInfo.ident)
}
inline std::string* OpInfo::mutable_ident() {
  std::string* _s = _internal_mutable_ident();
  // @@protoc_insertion_point(field_mutable:OpInfo.ident)
  return _s;
}
inline const std::string& OpInfo::_internal_ident() const {
  return ident_.Get();
}
inline void OpInfo::_internal_set_ident(const std::string& value) {
  
  ident_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OpInfo::_internal_mutable_ident() {
  
  return ident_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OpInfo::release_ident() {
  // @@protoc_insertion_point(field_release:OpInfo.ident)
  return ident_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OpInfo::set_allocated_ident(std::string* ident) {
  if (ident != nullptr) {
    
  } else {
    
  }
  ident_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ident,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:OpInfo.ident)
}

// uint64 timestamp = 2;
inline void OpInfo::clear_timestamp() {
  timestamp_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpInfo::_internal_timestamp() const {
  return timestamp_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 OpInfo::timestamp() const {
  // @@protoc_insertion_point(field_get:OpInfo.timestamp)
  return _internal_timestamp();
}
inline void OpInfo::_internal_set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  timestamp_ = value;
}
inline void OpInfo::set_timestamp(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_timestamp(value);
  // @@protoc_insertion_point(field_set:OpInfo.timestamp)
}

// string readable_name = 3;
inline void OpInfo::clear_readable_name() {
  readable_name_.ClearToEmpty();
}
inline const std::string& OpInfo::readable_name() const {
  // @@protoc_insertion_point(field_get:OpInfo.readable_name)
  return _internal_readable_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void OpInfo::set_readable_name(ArgT0&& arg0, ArgT... args) {
 
 readable_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:OpInfo.readable_name)
}
inline std::string* OpInfo::mutable_readable_name() {
  std::string* _s = _internal_mutable_readable_name();
  // @@protoc_insertion_point(field_mutable:OpInfo.readable_name)
  return _s;
}
inline const std::string& OpInfo::_internal_readable_name() const {
  return readable_name_.Get();
}
inline void OpInfo::_internal_set_readable_name(const std::string& value) {
  
  readable_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* OpInfo::_internal_mutable_readable_name() {
  
  return readable_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* OpInfo::release_readable_name() {
  // @@protoc_insertion_point(field_release:OpInfo.readable_name)
  return readable_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void OpInfo::set_allocated_readable_name(std::string* readable_name) {
  if (readable_name != nullptr) {
    
  } else {
    
  }
  readable_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), readable_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:OpInfo.readable_name)
}

// bool use_compression = 4;
inline void OpInfo::clear_use_compression() {
  use_compression_ = false;
}
inline bool OpInfo::_internal_use_compression() const {
  return use_compression_;
}
inline bool OpInfo::use_compression() const {
  // @@protoc_insertion_point(field_get:OpInfo.use_compression)
  return _internal_use_compression();
}
inline void OpInfo::_internal_set_use_compression(bool value) {
  
  use_compression_ = value;
}
inline void OpInfo::set_use_compression(bool value) {
  _internal_set_use_compression(value);
  // @@protoc_insertion_point(field_set:OpInfo.use_compression)
}

// -------------------------------------------------------------------

// StopInfo

// .OpInfo info = 1;
inline bool StopInfo::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool StopInfo::has_info() const {
  return _internal_has_info();
}
inline void StopInfo::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::OpInfo& StopInfo::_internal_info() const {
  const ::OpInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::OpInfo&>(
      ::_OpInfo_default_instance_);
}
inline const ::OpInfo& StopInfo::info() const {
  // @@protoc_insertion_point(field_get:StopInfo.info)
  return _internal_info();
}
inline void StopInfo::unsafe_arena_set_allocated_info(
    ::OpInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:StopInfo.info)
}
inline ::OpInfo* StopInfo::release_info() {
  
  ::OpInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OpInfo* StopInfo::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:StopInfo.info)
  
  ::OpInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::OpInfo* StopInfo::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::OpInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::OpInfo* StopInfo::mutable_info() {
  ::OpInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:StopInfo.info)
  return _msg;
}
inline void StopInfo::set_allocated_info(::OpInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::OpInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:StopInfo.info)
}

// bool error = 2;
inline void StopInfo::clear_error() {
  error_ = false;
}
inline bool StopInfo::_internal_error() const {
  return error_;
}
inline bool StopInfo::error() const {
  // @@protoc_insertion_point(field_get:StopInfo.error)
  return _internal_error();
}
inline void StopInfo::_internal_set_error(bool value) {
  
  error_ = value;
}
inline void StopInfo::set_error(bool value) {
  _internal_set_error(value);
  // @@protoc_insertion_point(field_set:StopInfo.error)
}

// -------------------------------------------------------------------

// TransferOpRequest

// .OpInfo info = 1;
inline bool TransferOpRequest::_internal_has_info() const {
  return this != internal_default_instance() && info_ != nullptr;
}
inline bool TransferOpRequest::has_info() const {
  return _internal_has_info();
}
inline void TransferOpRequest::clear_info() {
  if (GetArenaForAllocation() == nullptr && info_ != nullptr) {
    delete info_;
  }
  info_ = nullptr;
}
inline const ::OpInfo& TransferOpRequest::_internal_info() const {
  const ::OpInfo* p = info_;
  return p != nullptr ? *p : reinterpret_cast<const ::OpInfo&>(
      ::_OpInfo_default_instance_);
}
inline const ::OpInfo& TransferOpRequest::info() const {
  // @@protoc_insertion_point(field_get:TransferOpRequest.info)
  return _internal_info();
}
inline void TransferOpRequest::unsafe_arena_set_allocated_info(
    ::OpInfo* info) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(info_);
  }
  info_ = info;
  if (info) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:TransferOpRequest.info)
}
inline ::OpInfo* TransferOpRequest::release_info() {
  
  ::OpInfo* temp = info_;
  info_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::OpInfo* TransferOpRequest::unsafe_arena_release_info() {
  // @@protoc_insertion_point(field_release:TransferOpRequest.info)
  
  ::OpInfo* temp = info_;
  info_ = nullptr;
  return temp;
}
inline ::OpInfo* TransferOpRequest::_internal_mutable_info() {
  
  if (info_ == nullptr) {
    auto* p = CreateMaybeMessage<::OpInfo>(GetArenaForAllocation());
    info_ = p;
  }
  return info_;
}
inline ::OpInfo* TransferOpRequest::mutable_info() {
  ::OpInfo* _msg = _internal_mutable_info();
  // @@protoc_insertion_point(field_mutable:TransferOpRequest.info)
  return _msg;
}
inline void TransferOpRequest::set_allocated_info(::OpInfo* info) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete info_;
  }
  if (info) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::OpInfo>::GetOwningArena(info);
    if (message_arena != submessage_arena) {
      info = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, info, submessage_arena);
    }
    
  } else {
    
  }
  info_ = info;
  // @@protoc_insertion_point(field_set_allocated:TransferOpRequest.info)
}

// string sender_name = 2;
inline void TransferOpRequest::clear_sender_name() {
  sender_name_.ClearToEmpty();
}
inline const std::string& TransferOpRequest::sender_name() const {
  // @@protoc_insertion_point(field_get:TransferOpRequest.sender_name)
  return _internal_sender_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferOpRequest::set_sender_name(ArgT0&& arg0, ArgT... args) {
 
 sender_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransferOpRequest.sender_name)
}
inline std::string* TransferOpRequest::mutable_sender_name() {
  std::string* _s = _internal_mutable_sender_name();
  // @@protoc_insertion_point(field_mutable:TransferOpRequest.sender_name)
  return _s;
}
inline const std::string& TransferOpRequest::_internal_sender_name() const {
  return sender_name_.Get();
}
inline void TransferOpRequest::_internal_set_sender_name(const std::string& value) {
  
  sender_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::_internal_mutable_sender_name() {
  
  return sender_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::release_sender_name() {
  // @@protoc_insertion_point(field_release:TransferOpRequest.sender_name)
  return sender_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferOpRequest::set_allocated_sender_name(std::string* sender_name) {
  if (sender_name != nullptr) {
    
  } else {
    
  }
  sender_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sender_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TransferOpRequest.sender_name)
}

// string receiver_name = 3;
inline void TransferOpRequest::clear_receiver_name() {
  receiver_name_.ClearToEmpty();
}
inline const std::string& TransferOpRequest::receiver_name() const {
  // @@protoc_insertion_point(field_get:TransferOpRequest.receiver_name)
  return _internal_receiver_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferOpRequest::set_receiver_name(ArgT0&& arg0, ArgT... args) {
 
 receiver_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransferOpRequest.receiver_name)
}
inline std::string* TransferOpRequest::mutable_receiver_name() {
  std::string* _s = _internal_mutable_receiver_name();
  // @@protoc_insertion_point(field_mutable:TransferOpRequest.receiver_name)
  return _s;
}
inline const std::string& TransferOpRequest::_internal_receiver_name() const {
  return receiver_name_.Get();
}
inline void TransferOpRequest::_internal_set_receiver_name(const std::string& value) {
  
  receiver_name_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::_internal_mutable_receiver_name() {
  
  return receiver_name_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::release_receiver_name() {
  // @@protoc_insertion_point(field_release:TransferOpRequest.receiver_name)
  return receiver_name_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferOpRequest::set_allocated_receiver_name(std::string* receiver_name) {
  if (receiver_name != nullptr) {
    
  } else {
    
  }
  receiver_name_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver_name,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TransferOpRequest.receiver_name)
}

// string receiver = 4;
inline void TransferOpRequest::clear_receiver() {
  receiver_.ClearToEmpty();
}
inline const std::string& TransferOpRequest::receiver() const {
  // @@protoc_insertion_point(field_get:TransferOpRequest.receiver)
  return _internal_receiver();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferOpRequest::set_receiver(ArgT0&& arg0, ArgT... args) {
 
 receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransferOpRequest.receiver)
}
inline std::string* TransferOpRequest::mutable_receiver() {
  std::string* _s = _internal_mutable_receiver();
  // @@protoc_insertion_point(field_mutable:TransferOpRequest.receiver)
  return _s;
}
inline const std::string& TransferOpRequest::_internal_receiver() const {
  return receiver_.Get();
}
inline void TransferOpRequest::_internal_set_receiver(const std::string& value) {
  
  receiver_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::_internal_mutable_receiver() {
  
  return receiver_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::release_receiver() {
  // @@protoc_insertion_point(field_release:TransferOpRequest.receiver)
  return receiver_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferOpRequest::set_allocated_receiver(std::string* receiver) {
  if (receiver != nullptr) {
    
  } else {
    
  }
  receiver_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), receiver,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TransferOpRequest.receiver)
}

// uint64 size = 5;
inline void TransferOpRequest::clear_size() {
  size_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferOpRequest::_internal_size() const {
  return size_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferOpRequest::size() const {
  // @@protoc_insertion_point(field_get:TransferOpRequest.size)
  return _internal_size();
}
inline void TransferOpRequest::_internal_set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  size_ = value;
}
inline void TransferOpRequest::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_size(value);
  // @@protoc_insertion_point(field_set:TransferOpRequest.size)
}

// uint64 count = 6;
inline void TransferOpRequest::clear_count() {
  count_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferOpRequest::_internal_count() const {
  return count_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransferOpRequest::count() const {
  // @@protoc_insertion_point(field_get:TransferOpRequest.count)
  return _internal_count();
}
inline void TransferOpRequest::_internal_set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  count_ = value;
}
inline void TransferOpRequest::set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_count(value);
  // @@protoc_insertion_point(field_set:TransferOpRequest.count)
}

// string name_if_single = 7;
inline void TransferOpRequest::clear_name_if_single() {
  name_if_single_.ClearToEmpty();
}
inline const std::string& TransferOpRequest::name_if_single() const {
  // @@protoc_insertion_point(field_get:TransferOpRequest.name_if_single)
  return _internal_name_if_single();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferOpRequest::set_name_if_single(ArgT0&& arg0, ArgT... args) {
 
 name_if_single_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransferOpRequest.name_if_single)
}
inline std::string* TransferOpRequest::mutable_name_if_single() {
  std::string* _s = _internal_mutable_name_if_single();
  // @@protoc_insertion_point(field_mutable:TransferOpRequest.name_if_single)
  return _s;
}
inline const std::string& TransferOpRequest::_internal_name_if_single() const {
  return name_if_single_.Get();
}
inline void TransferOpRequest::_internal_set_name_if_single(const std::string& value) {
  
  name_if_single_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::_internal_mutable_name_if_single() {
  
  return name_if_single_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::release_name_if_single() {
  // @@protoc_insertion_point(field_release:TransferOpRequest.name_if_single)
  return name_if_single_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferOpRequest::set_allocated_name_if_single(std::string* name_if_single) {
  if (name_if_single != nullptr) {
    
  } else {
    
  }
  name_if_single_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name_if_single,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TransferOpRequest.name_if_single)
}

// string mime_if_single = 8;
inline void TransferOpRequest::clear_mime_if_single() {
  mime_if_single_.ClearToEmpty();
}
inline const std::string& TransferOpRequest::mime_if_single() const {
  // @@protoc_insertion_point(field_get:TransferOpRequest.mime_if_single)
  return _internal_mime_if_single();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransferOpRequest::set_mime_if_single(ArgT0&& arg0, ArgT... args) {
 
 mime_if_single_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:TransferOpRequest.mime_if_single)
}
inline std::string* TransferOpRequest::mutable_mime_if_single() {
  std::string* _s = _internal_mutable_mime_if_single();
  // @@protoc_insertion_point(field_mutable:TransferOpRequest.mime_if_single)
  return _s;
}
inline const std::string& TransferOpRequest::_internal_mime_if_single() const {
  return mime_if_single_.Get();
}
inline void TransferOpRequest::_internal_set_mime_if_single(const std::string& value) {
  
  mime_if_single_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::_internal_mutable_mime_if_single() {
  
  return mime_if_single_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransferOpRequest::release_mime_if_single() {
  // @@protoc_insertion_point(field_release:TransferOpRequest.mime_if_single)
  return mime_if_single_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransferOpRequest::set_allocated_mime_if_single(std::string* mime_if_single) {
  if (mime_if_single != nullptr) {
    
  } else {
    
  }
  mime_if_single_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), mime_if_single,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:TransferOpRequest.mime_if_single)
}

// repeated string top_dir_basenames = 9;
inline int TransferOpRequest::_internal_top_dir_basenames_size() const {
  return top_dir_basenames_.size();
}
inline int TransferOpRequest::top_dir_basenames_size() const {
  return _internal_top_dir_basenames_size();
}
inline void TransferOpRequest::clear_top_dir_basenames() {
  top_dir_basenames_.Clear();
}
inline std::string* TransferOpRequest::add_top_dir_basenames() {
  std::string* _s = _internal_add_top_dir_basenames();
  // @@protoc_insertion_point(field_add_mutable:TransferOpRequest.top_dir_basenames)
  return _s;
}
inline const std::string& TransferOpRequest::_internal_top_dir_basenames(int index) const {
  return top_dir_basenames_.Get(index);
}
inline const std::string& TransferOpRequest::top_dir_basenames(int index) const {
  // @@protoc_insertion_point(field_get:TransferOpRequest.top_dir_basenames)
  return _internal_top_dir_basenames(index);
}
inline std::string* TransferOpRequest::mutable_top_dir_basenames(int index) {
  // @@protoc_insertion_point(field_mutable:TransferOpRequest.top_dir_basenames)
  return top_dir_basenames_.Mutable(index);
}
inline void TransferOpRequest::set_top_dir_basenames(int index, const std::string& value) {
  top_dir_basenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:TransferOpRequest.top_dir_basenames)
}
inline void TransferOpRequest::set_top_dir_basenames(int index, std::string&& value) {
  top_dir_basenames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:TransferOpRequest.top_dir_basenames)
}
inline void TransferOpRequest::set_top_dir_basenames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  top_dir_basenames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:TransferOpRequest.top_dir_basenames)
}
inline void TransferOpRequest::set_top_dir_basenames(int index, const char* value, size_t size) {
  top_dir_basenames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:TransferOpRequest.top_dir_basenames)
}
inline std::string* TransferOpRequest::_internal_add_top_dir_basenames() {
  return top_dir_basenames_.Add();
}
inline void TransferOpRequest::add_top_dir_basenames(const std::string& value) {
  top_dir_basenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:TransferOpRequest.top_dir_basenames)
}
inline void TransferOpRequest::add_top_dir_basenames(std::string&& value) {
  top_dir_basenames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:TransferOpRequest.top_dir_basenames)
}
inline void TransferOpRequest::add_top_dir_basenames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  top_dir_basenames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:TransferOpRequest.top_dir_basenames)
}
inline void TransferOpRequest::add_top_dir_basenames(const char* value, size_t size) {
  top_dir_basenames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:TransferOpRequest.top_dir_basenames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TransferOpRequest::top_dir_basenames() const {
  // @@protoc_insertion_point(field_list:TransferOpRequest.top_dir_basenames)
  return top_dir_basenames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TransferOpRequest::mutable_top_dir_basenames() {
  // @@protoc_insertion_point(field_mutable_list:TransferOpRequest.top_dir_basenames)
  return &top_dir_basenames_;
}

// -------------------------------------------------------------------

// FileChunk

// string relative_path = 1;
inline void FileChunk::clear_relative_path() {
  relative_path_.ClearToEmpty();
}
inline const std::string& FileChunk::relative_path() const {
  // @@protoc_insertion_point(field_get:FileChunk.relative_path)
  return _internal_relative_path();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileChunk::set_relative_path(ArgT0&& arg0, ArgT... args) {
 
 relative_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileChunk.relative_path)
}
inline std::string* FileChunk::mutable_relative_path() {
  std::string* _s = _internal_mutable_relative_path();
  // @@protoc_insertion_point(field_mutable:FileChunk.relative_path)
  return _s;
}
inline const std::string& FileChunk::_internal_relative_path() const {
  return relative_path_.Get();
}
inline void FileChunk::_internal_set_relative_path(const std::string& value) {
  
  relative_path_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileChunk::_internal_mutable_relative_path() {
  
  return relative_path_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileChunk::release_relative_path() {
  // @@protoc_insertion_point(field_release:FileChunk.relative_path)
  return relative_path_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileChunk::set_allocated_relative_path(std::string* relative_path) {
  if (relative_path != nullptr) {
    
  } else {
    
  }
  relative_path_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), relative_path,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FileChunk.relative_path)
}

// int32 file_type = 2;
inline void FileChunk::clear_file_type() {
  file_type_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileChunk::_internal_file_type() const {
  return file_type_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 FileChunk::file_type() const {
  // @@protoc_insertion_point(field_get:FileChunk.file_type)
  return _internal_file_type();
}
inline void FileChunk::_internal_set_file_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  file_type_ = value;
}
inline void FileChunk::set_file_type(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_file_type(value);
  // @@protoc_insertion_point(field_set:FileChunk.file_type)
}

// string symlink_target = 3;
inline void FileChunk::clear_symlink_target() {
  symlink_target_.ClearToEmpty();
}
inline const std::string& FileChunk::symlink_target() const {
  // @@protoc_insertion_point(field_get:FileChunk.symlink_target)
  return _internal_symlink_target();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileChunk::set_symlink_target(ArgT0&& arg0, ArgT... args) {
 
 symlink_target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileChunk.symlink_target)
}
inline std::string* FileChunk::mutable_symlink_target() {
  std::string* _s = _internal_mutable_symlink_target();
  // @@protoc_insertion_point(field_mutable:FileChunk.symlink_target)
  return _s;
}
inline const std::string& FileChunk::_internal_symlink_target() const {
  return symlink_target_.Get();
}
inline void FileChunk::_internal_set_symlink_target(const std::string& value) {
  
  symlink_target_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileChunk::_internal_mutable_symlink_target() {
  
  return symlink_target_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileChunk::release_symlink_target() {
  // @@protoc_insertion_point(field_release:FileChunk.symlink_target)
  return symlink_target_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileChunk::set_allocated_symlink_target(std::string* symlink_target) {
  if (symlink_target != nullptr) {
    
  } else {
    
  }
  symlink_target_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), symlink_target,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FileChunk.symlink_target)
}

// bytes chunk = 4;
inline void FileChunk::clear_chunk() {
  chunk_.ClearToEmpty();
}
inline const std::string& FileChunk::chunk() const {
  // @@protoc_insertion_point(field_get:FileChunk.chunk)
  return _internal_chunk();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void FileChunk::set_chunk(ArgT0&& arg0, ArgT... args) {
 
 chunk_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:FileChunk.chunk)
}
inline std::string* FileChunk::mutable_chunk() {
  std::string* _s = _internal_mutable_chunk();
  // @@protoc_insertion_point(field_mutable:FileChunk.chunk)
  return _s;
}
inline const std::string& FileChunk::_internal_chunk() const {
  return chunk_.Get();
}
inline void FileChunk::_internal_set_chunk(const std::string& value) {
  
  chunk_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* FileChunk::_internal_mutable_chunk() {
  
  return chunk_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* FileChunk::release_chunk() {
  // @@protoc_insertion_point(field_release:FileChunk.chunk)
  return chunk_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void FileChunk::set_allocated_chunk(std::string* chunk) {
  if (chunk != nullptr) {
    
  } else {
    
  }
  chunk_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chunk,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:FileChunk.chunk)
}

// uint32 file_mode = 5;
inline void FileChunk::clear_file_mode() {
  file_mode_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FileChunk::_internal_file_mode() const {
  return file_mode_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 FileChunk::file_mode() const {
  // @@protoc_insertion_point(field_get:FileChunk.file_mode)
  return _internal_file_mode();
}
inline void FileChunk::_internal_set_file_mode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  file_mode_ = value;
}
inline void FileChunk::set_file_mode(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_file_mode(value);
  // @@protoc_insertion_point(field_set:FileChunk.file_mode)
}

// -------------------------------------------------------------------

// RegRequest

// string ip = 1;
inline void RegRequest::clear_ip() {
  ip_.ClearToEmpty();
}
inline const std::string& RegRequest::ip() const {
  // @@protoc_insertion_point(field_get:RegRequest.ip)
  return _internal_ip();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegRequest::set_ip(ArgT0&& arg0, ArgT... args) {
 
 ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RegRequest.ip)
}
inline std::string* RegRequest::mutable_ip() {
  std::string* _s = _internal_mutable_ip();
  // @@protoc_insertion_point(field_mutable:RegRequest.ip)
  return _s;
}
inline const std::string& RegRequest::_internal_ip() const {
  return ip_.Get();
}
inline void RegRequest::_internal_set_ip(const std::string& value) {
  
  ip_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegRequest::_internal_mutable_ip() {
  
  return ip_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegRequest::release_ip() {
  // @@protoc_insertion_point(field_release:RegRequest.ip)
  return ip_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegRequest::set_allocated_ip(std::string* ip) {
  if (ip != nullptr) {
    
  } else {
    
  }
  ip_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ip,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RegRequest.ip)
}

// string hostname = 2;
inline void RegRequest::clear_hostname() {
  hostname_.ClearToEmpty();
}
inline const std::string& RegRequest::hostname() const {
  // @@protoc_insertion_point(field_get:RegRequest.hostname)
  return _internal_hostname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegRequest::set_hostname(ArgT0&& arg0, ArgT... args) {
 
 hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RegRequest.hostname)
}
inline std::string* RegRequest::mutable_hostname() {
  std::string* _s = _internal_mutable_hostname();
  // @@protoc_insertion_point(field_mutable:RegRequest.hostname)
  return _s;
}
inline const std::string& RegRequest::_internal_hostname() const {
  return hostname_.Get();
}
inline void RegRequest::_internal_set_hostname(const std::string& value) {
  
  hostname_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegRequest::_internal_mutable_hostname() {
  
  return hostname_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegRequest::release_hostname() {
  // @@protoc_insertion_point(field_release:RegRequest.hostname)
  return hostname_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegRequest::set_allocated_hostname(std::string* hostname) {
  if (hostname != nullptr) {
    
  } else {
    
  }
  hostname_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), hostname,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RegRequest.hostname)
}

// -------------------------------------------------------------------

// RegResponse

// string locked_cert = 1;
inline void RegResponse::clear_locked_cert() {
  locked_cert_.ClearToEmpty();
}
inline const std::string& RegResponse::locked_cert() const {
  // @@protoc_insertion_point(field_get:RegResponse.locked_cert)
  return _internal_locked_cert();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void RegResponse::set_locked_cert(ArgT0&& arg0, ArgT... args) {
 
 locked_cert_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:RegResponse.locked_cert)
}
inline std::string* RegResponse::mutable_locked_cert() {
  std::string* _s = _internal_mutable_locked_cert();
  // @@protoc_insertion_point(field_mutable:RegResponse.locked_cert)
  return _s;
}
inline const std::string& RegResponse::_internal_locked_cert() const {
  return locked_cert_.Get();
}
inline void RegResponse::_internal_set_locked_cert(const std::string& value) {
  
  locked_cert_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* RegResponse::_internal_mutable_locked_cert() {
  
  return locked_cert_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* RegResponse::release_locked_cert() {
  // @@protoc_insertion_point(field_release:RegResponse.locked_cert)
  return locked_cert_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void RegResponse::set_allocated_locked_cert(std::string* locked_cert) {
  if (locked_cert != nullptr) {
    
  } else {
    
  }
  locked_cert_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), locked_cert,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:RegResponse.locked_cert)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_warp_2eproto
